#!/usr/bin/ruby

# A bit messy... allows (clean up to come), choose better var.
# 1 - Connect to a remote machine (SINGLE machine)
# 2 - SCP files to/from a set of machines (MULTIPLE machines)
# 3 - Run in line command on a set of machines (MULTIPLE machines)
# 4 - Run script on a set of machines (MULTIPLE machines)

require 'optparse'
require 'pp'



@config_path = ENV["HOME"] + "/.connect2"

def escape_quotes(str)
   return str.gsub("\"", "\\\"")
end

def run_command cmd
   process = IO.popen(cmd)
   process.sync = true
   process.each { |s| print s }
end

def write_config config
    config_as_str = PP.pp(config, '')
    File.open(@config_path, 'w') { |file| file.write(config_as_str) }
end

if !File.file?(@config_path) then
    write_config({})
end
   
@config = eval(File.read(@config_path))
@machines = @config[:machines]

options = {}
op = OptionParser.new do |opts|
   opts.on("-c", "--command [command_to_run]", "command") do | command |
     options[:command] = command
   end
   opts.on("-t", "--scp", "Transfer file (SCP)") do | scp |
     options[:scp] = scp
   end
   opts.on("-r", "--recursive", "SCP recursive") do | arg |
     options[:r] = arg
   end
   opts.on("-a", "--action [action]", "Action (post or get)") do | arg |
     options[:action] = arg
   end
   opts.on("-l", "--localpath [localpath]", "Path to local file or directory") do | arg |
     options[:localpath] = arg
   end
   opts.on("-s", "--serverpath [serverpath]", "Path to remote file or directory") do | arg |
     options[:remotepath] = arg
   end
   opts.on("-p", "--path_to_script [scipt_path]",
	            "Script to execute remotely") do | script |
	             options[:script] = script
   end
   opts.on("-m", "--machines [':' sperated list machine aliases]", "Machine aliases to connect to") do | arg |
     options[:aliases] = arg
   end

   opts.on_tail("-h", "--help", "Show this message") do
     puts opts
     exit			 
  end
end.parse!

ARGV.clear

# Sent of aliased machines being addressed
end_points = options[:aliases] ? options[:aliases].split(":") : nil

if end_points then
        selected_machines = @machines.select { | machine | end_points.index(machine[:alias]) }
        if selected_machines.empty? then
            puts "Unknown hosts #{end_points}, exiting."
            exit
        end
else
        puts "No end point specified"
	@machines.each_with_index { | machine, index | 
           STDOUT.puts "[#{index}] #{machine[:alias]} => #{machine[:host]}:#{machine[:port]}"
        }
        print "Select your host(s): "
        selection_indexes = gets.chop.split(/[^\d+]/).reject { |s| s.empty? }.collect { | str | str.to_i }.sort
        if selection_indexes.empty? then
             puts "None selected, exiting."
             exit
        # Validate selected indices
        elsif selection_indexes.min < 0 or selection_indexes.max > @machines.size then
             puts "Invalid selection, exiting."
             exit
        end 
        selected_machines = @machines.values_at(*selection_indexes)
end

if options[:scp] then
   # Transfer file to/from remote machine
   selected_machines.each do | connect_to |
     puts "host: #{connect_to[:host]}"
     puts "Top of scp"
     recurive_opt = options[:r] ? " -r" : ""
     remote = "#{connect_to[:host]}:\"#{options[:remotepath]}\""
     command = nil
     scp = "scp#{recurive_opt} -P #{connect_to[:port]}"
     if options[:action] == "get" then
	     command = "#{scp} #{remote} \"#{options[:localpath]}\""
     elsif options[:action] == "post" then
	     command = "#{scp} \"#{options[:localpath]}\" #{remote}"
     else
        puts "Missing or invalid scp action"
        exit
     end
     puts "Running #{command}"
     run_command(command)
   end
elsif options[:script] then
   selected_machines.each do | connect_to |
      puts "Running script #{options[:script]} on #{connect_to[:alias]}"
      File.readlines(options[:script]).each do | line |
        if !line.empty? then
command=<<mark
ssh #{connect_to[:host]} -p #{connect_to[:port]} "source .bashrc; #{escape_quotes(line.strip())}"
mark
          run_command(command)
	end
      end
   end
elsif !options[:command] then
   # Connect to machine
   connect_to = selected_machines[0]
   puts "Connection to #{connect_to[:host]}"
   command = "ssh #{connect_to[:host]} -p #{connect_to[:port]}"
   puts "Running: #{command}"
   exec(command)

else
   # Run command remotely
   selected_machines.each do | connect_to |
     cmd = "ssh #{connect_to[:host]} -p #{connect_to[:port]} 'source .bashrc; #{options[:command]}' "
     puts "Runnig #{cmd}"
     run_command(cmd)
   end
end
